"use strict";
/*
 * Copyright 2021 Evernote Corporation. All rights reserved.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.lexoRankReconciler = exports.lexoRankReconcilerChanges = void 0;
const simply_immutable_1 = require("simply-immutable");
const lexoRank_1 = require("./lexoRank");
/*
 * This function is able to take a list of nodes with weights, and nodes with orders, and make the necessary changes
 * on the nodes with weights entries to put the weights back in specified order. The changes out have all the necessary changes
 * to make to get original match the changes. Null entries mean a delete, and there is no difference between a create and an update.
 * nodes with no changes have no entries in changesOut
 */
function lexoRankReconcilerChanges(original, updatedOrder) {
    const changesOut = {};
    let inserts = [];
    let lastWeight = '';
    function processInserts(high = '') {
        for (const i of inserts) {
            lastWeight = lexoRank_1.lexoRank(lastWeight, high);
            changesOut[i] = lastWeight;
        }
        inserts = [];
    }
    // Preprocessing: Find the deletes and remove them from original
    for (const origId in original) {
        if (updatedOrder.indexOf(origId) === -1) {
            changesOut[origId] = null;
            delete original[origId];
        }
    }
    const originalOrder = Object.getOwnPropertyNames(original);
    originalOrder.sort((a, b) => {
        if (original[a] === original[b]) {
            return 0;
        }
        return original[a] > original[b] ? 1 : -1;
    });
    const origIndexes = {};
    const updatedIndexes = {};
    const existingIndexes = {};
    originalOrder.forEach((id, i) => {
        origIndexes[id] = i;
    });
    updatedOrder.forEach((id, i) => {
        updatedIndexes[id] = i;
        if (origIndexes[id] !== undefined) {
            existingIndexes[id] = Object.keys(existingIndexes).length;
        }
    });
    let origIndex = 0;
    let upIndex = 0;
    let existingIndex = 0;
    while (origIndex < originalOrder.length && upIndex < updatedOrder.length) {
        const upID = updatedOrder[upIndex];
        const origID = originalOrder[origIndex];
        if (origID !== upID) {
            // No need to handle deletes, done in preprocessing step
            if (origIndexes[upID] === undefined) {
                // Handle new inserts into the middle of the list
                inserts.push(upID);
                upIndex++;
            }
            else {
                const relOrigPos = existingIndexes[origID] - existingIndex;
                const relUpdatedPos = origIndexes[upID] - origIndex;
                if (relOrigPos - relUpdatedPos === 0) {
                    // Both elements were found at a relative distance from eachother, this is a swap
                    // Update only the incoming node (current node will get updated when second mismatch is found)
                    const currWeight = original[origID];
                    processInserts(currWeight);
                    changesOut[upID] = currWeight;
                    upIndex++;
                    origIndex++;
                    existingIndex++;
                    lastWeight = currWeight;
                }
                else if (relUpdatedPos < 0 || relOrigPos < relUpdatedPos) {
                    // The incoming element was moved
                    inserts.push(upID);
                    upIndex++;
                    existingIndex++;
                }
                else {
                    origIndex++;
                }
            }
        }
        else {
            processInserts(original[origID]);
            upIndex++;
            origIndex++;
            existingIndex++;
            lastWeight = original[origID];
        }
    }
    // Handle extra nodes at the bottom of the list as inserts
    while (upIndex < updatedOrder.length) {
        inserts.push(updatedOrder[upIndex]);
        upIndex++;
    }
    processInserts();
    return changesOut;
}
exports.lexoRankReconcilerChanges = lexoRankReconcilerChanges;
function lexoRankReconciler(original, updatedOrder, changesOut) {
    const updatedWeightsOut = simply_immutable_1.cloneMutable(original);
    const changes = lexoRankReconcilerChanges(original, updatedOrder);
    const orderOut = [];
    for (const nodeID in changes) {
        if (changesOut) {
            changesOut[nodeID] = changes[nodeID];
        }
        if (changes[nodeID] !== null) {
            updatedWeightsOut[nodeID] = changes[nodeID];
        }
        else {
            delete updatedWeightsOut[nodeID];
        }
    }
    for (const nodeID in updatedWeightsOut) {
        orderOut.push(nodeID);
    }
    orderOut.sort((a, b) => {
        if (updatedWeightsOut[a] === updatedWeightsOut[b]) {
            return 0;
        }
        return updatedWeightsOut[a] < updatedWeightsOut[b] ? -1 : 1;
    });
    return {
        weights: updatedWeightsOut,
        order: orderOut,
    };
}
exports.lexoRankReconciler = lexoRankReconciler;
//# sourceMappingURL=LexoRankReconciler.js.map